name: Celerity CI

# We currently run this workflow on three different triggers,
# which all have subtly different semantics.
on:
  # Run workflow on any push to any branch.
  push:
  # Also run on internal PRs. The difference to the "push" trigger
  # being, that the workflow will run on the result of merging the PR's
  # commits into the target branch.
  pull_request:
    branches-ignore:
      # Ignore branches from forks (which contain a colon).
      - '**:**'
  # Finally, also run on external PRs. By using the "_target" trigger,
  # we can ensure that the workflow definition itself will always come
  # from the main repository, not the fork (for security reasons).
  pull_request_target:
    branches:
      # Only consider branches from forks (which contain a colon).
      - '**:**'

jobs:
  checkout:
    runs-on: [self-hosted]
    steps:
      - uses: actions/checkout@v2
        with:
          # We clean up artifacts ourselves.
          # Cleaning here can cause problems with concurrent workflow runs,
          # where build folders are being removed mid-run.
          clean: false
          submodules: true

  build:
    needs: [checkout]
    runs-on: [self-hosted]
    strategy:
      fail-fast: false
      matrix:
        SYCL-impl: ["hipSYCL", "ComputeCpp"]
        build-type: ["Debug", "Release"]
    env:
      # FIXME: Can we keep this DRY?
      build-name: build-${{ matrix.SYCL-impl }}-${{ matrix.build-type }}-${{ github.run_id }}-${{ github.run_number }}
    steps:
      - name: Run build script
        run: |
          mkdir ${{ env.build-name }}
          set -o pipefail
          cd ${{ env.build-name }} && /scripts/build.sh ${{ matrix.SYCL-impl }} ${{ matrix.build-type }} | tee ${{ env.build-name }}.log
      # Upload build log for report step
      - name: Upload build log
        uses: actions/upload-artifact@v1
        with:
          name: ${{ env.build-name }}-log
          path: ${{ env.build-name }}/${{ env.build-name }}.log

  test:
    needs: [build]
    runs-on: [self-hosted]
    # FIXME: Can we keep this DRY?
    strategy:
      fail-fast: false
      matrix:
        SYCL-impl: ["hipSYCL", "ComputeCpp"]
        build-type: ["Debug", "Release"]
    env:
      # FIXME: Can we keep this DRY?
      build-name: build-${{ matrix.SYCL-impl }}-${{ matrix.build-type }}-${{ github.run_id }}-${{ github.run_number }}
      # Run ComputeCpp tests on host device instead of NVIDIA, as the PTX backend is no longer officially supported.
      # Celerity uses a GPU selector by default. To override this behavior, we have to set CELERITY_DEVICES to
      # platform 0 (which happens to be the host platform for ComputeCpp) and use device 0 on up to 4 Celerity workers.
      # TODO: Come up with more robust solution for setting device type on a per-implementation basis,
      #       which also doesn't require knowing the index of the particular platform.
      # For other implementations, simply pass an empty value, which is then ignored.
      # Workflow syntax doesn't support the ternary operator, so we have to use a bit of a hack here.
      CELERITY_DEVICES: ${{ fromJSON('["", "0 0 0 0 0"]')[matrix.SYCL-impl == 'ComputeCpp'] }}
    steps:
      - name: Run unit tests
        working-directory: ${{ env.build-name }}
        # Running "make test" is slow (why?), so we just call all test executables manually
        run: find test -maxdepth 1 -executable -type f -print0 | xargs -0 -n1 bash -c
      - name: Run integration tests
        working-directory: ${{ env.build-name }}
        run: ${{ github.workspace }}/ci/run-integration-tests.sh /data/Lenna.png 1 2 4

  report:
    needs: [test]
    runs-on: [self-hosted]
    steps:
      - name: Check code formatting
        id: formatting
        run: |
          unformatted=$("./ci/find-unformatted-files.sh")
          unformatted=${unformatted//$'\n'/'%0A'}
          echo "::set-output name=unformatted-files::$unformatted"
      - uses: "celerity/ci-report-action@v3"
        with:
          gh-token: ${{ secrets.GITHUB_TOKEN }}
          unformatted-files: ${{ steps.formatting.outputs.unformatted-files }}
          # FIXME: Can we somehow keep this DRY with the matrix config above?
          builds: "hipSYCL-Debug, hipSYCL-Release, ComputeCpp-Debug, ComputeCpp-Release"

  cleanup:
    needs: [report]
    if: always() # Execute even if our dependencies fail
    runs-on: [self-hosted]
    # FIXME: Can we keep this DRY?
    strategy:
      fail-fast: false
      matrix:
        SYCL-impl: ["hipSYCL", "ComputeCpp"]
        build-type: ["Debug", "Release"]
    env:
      # FIXME: Can we keep this DRY?
      build-name: build-${{ matrix.SYCL-impl }}-${{ matrix.build-type }}-${{ github.run_id }}-${{ github.run_number }}
    steps:
      - name: Remove build directory
        run: rm -rf ${{ env.build-name }}
      # The report step downloads build logs for analysis
      # FIXME: Either read build logs directly from within build folder (don't download them again),
      #        or at least clean up directly within report action script.
      - name: Remove build log
        run: rm -f ${{ env.build-name }}.log
